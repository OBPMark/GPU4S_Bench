
std::string kernel_code = 
"void kernel kernel_matrix_convolution(global const bench_t* A,  global bench_t* B, global const bench_t* kernel_data, const int n, const int m, const int w, const int kernel_size ) {\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"unsigned int size = n;\n"
"int kernel_rad = kernel_size / 2;\n"
"bench_t sum = 0;\n"
"if (x < size && y < size){\n"
"for(int i = -kernel_rad; i <= kernel_rad; ++i) // loop over kernel_rad  -1 to 1 in kernel_size 3\n"
"{\n"
"for(int j = -kernel_rad; j <= kernel_rad; ++j)\n"
"{\n"
"bench_t value = 0;\n"
"if (i + x < 0 || j + y < 0)\n"
"{\n"
"value = 0;\n"
"}\n"
"else if ( i + x > size - 1 || j + y > size - 1)\n"
"{\n"
"value = 0;\n"
"}\n"
"else\n"
"{\n"
"value = A[(x + i)*size+(y + j)];\n"
"}\n"
"sum += value * kernel_data[(i+kernel_rad)* kernel_size + (j+kernel_rad)];\n"
"}\n"
"}\n"
"B[x*size+y ] = sum;\n"
"}\n"
"}\n"
"void kernel kernel_relu(global const bench_t* A, global bench_t* B, const int size ){\n"
"int i = get_global_id(0);\n"
"int j = get_global_id(1);\n"
"if (i < size && j < size){\n"
"bench_t threshold = 0;\n"
"B[i*size+j] = max(threshold, A[i*size+j]);\n"
"}\n"
"}\n"
"void kernel kernel_max(global const bench_t* A, global bench_t* B, const int size, const  int stride,  const  int lateral_stride ){\n"
"int i = get_global_id(0);\n"
"int j = get_global_id(1);\n"
"if (i < size && j < size) {\n"
"bench_t max_value = A[((i * stride)) * size + ((j*stride))];\n"
"for(unsigned int x = 0; x < stride; ++x)\n"
"{\n"
"for(unsigned int y = 0; y < stride; ++y)\n"
"{\n"
"max_value = max(max_value, A[((i * stride) + x) * size + ((j*stride) +y)]);\n"
"}\n"
"}\n"
"B[i * lateral_stride + j ] = max_value;\n"
"}\n"
"}\n"
"void kernel kernel_lrn(global const bench_t* A, global bench_t* B, const int size, const bench_t K, const bench_t ALPHA, const bench_t BETA ){\n"
"int i = get_global_id(0);\n"
"int j = get_global_id(1);\n"
"if (i < size && j < size){\n"
"B[i*size+j] = A[i*size+j]/pow((K+ALPHA*pow(A[i*size+j],2)),BETA);\n"
"}\n"
"}\n"
"void kernel kernel_matrix_multiplication(global const bench_t* A, const global bench_t* B, global bench_t* C, const int n, const int m, const int w ){\n"
"int i = get_global_id(0);\n"
"int j = get_global_id(1);\n"
"if (i < n && j < m){\n"
"bench_t acumulated = 0;\n"
"for (unsigned int k_d = 0; k_d < w; ++k_d )\n"
"{\n"
"acumulated += A[i*w+k_d] * B[k_d*m +j];\n"
"}\n"
"C[i*m+j] =  acumulated;\n"
"}\n"
"}\n"
"void kernel kernel_relu_linear(global const bench_t* A, global bench_t* B, const int size ){\n"
"int i = get_global_id(0);\n"
"if (i < size){\n"
"bench_t threshold = 0;\n"
"B[i] = max(threshold, A[i]);\n"
"}\n"
"}\n"
"void kernel kernel_softmax(global const bench_t* A, global bench_t* B, global bench_t* sum_d_B, const int size ){\n"
"int i = get_global_id(0);\n"
"int j = get_global_id(1);\n"
"if (i < size && j < size){\n"
"B[i*size+j] = exp(A[i*size+j]);\n"
"atomic_add_global(sum_d_B, B[i*size+j]);\n"
"}\n"
"}\n"
"void kernel kernel_softmax_end(global  bench_t* B, global bench_t* sum_d_B, const int size ){\n"
"int i = get_global_id(0);\n"
"int j = get_global_id(1);\n"
"if (i < size && j < size){\n"
"B[i*size+j] = (B[i*size+j]/(*sum_d_B));\n"
"}\n"
"}\n"
;
